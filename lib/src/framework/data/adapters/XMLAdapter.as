/*                                   ,----,                                 
 *                                 ,/   .`|                                 
 *      ,---,       .--.--.      ,`   .'  :,-.----.      ,---,    ,---,     
 *     '  .' \     /  /    '.  ;    ;     /\    /  \  ,`--.' |  .'  .' `\   
 *    /  ;    '.  |  :  /`. /.'___,/    ,' ;   :    \ |   :  :,---.'     \  
 *   :  :       \ ;  |  |--` |    :     |  |   | .\ : :   |  '|   |  .`\  | 
 *   :  |   /\   \|  :  ;_   ;    |.';  ;  .   : |: | |   :  |:   : |  '  | 
 *   |  :  ' ;.   :\  \    `.`----'  |  |  |   |  \ : '   '  ;|   ' '  ;  : 
 *   |  |  ;/  \   \`----.   \   '   :  ;  |   : .  / |   |  |'   | ;  .  | 
 *   '  :  | \  \ ,'__ \  \  |   |   |  '  ;   | |  \ '   :  ;|   | :  |  ' 
 *   |  |  '  '--' /  /`--'  /   '   :  |  |   | ;\  \|   |  ''   : | /  ;  
 *   |  :  :      '--'.     /    ;   |.'   :   ' | \.''   :  ||   | '` ,/   
 *   |  | ,'        `--'---'     '---'     :   : :-'  ;   |.' ;   :  .'     
 *   `--''                                 |   |.'    '---'   |   ,.' Tyler      
 * ActionScript tested rapid iterative dev `---' Copyright2010'---'  Larson
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 * http://www.gnu.org/licenses
 */
package framework.data.adapters 
{
	import flash.events.*;
	import flash.net.*;
	import framework.cache.*;
	import framework.data.*;
	import framework.net.*;
	import framework.utils.*;
	
	public class XMLAdapter extends AdapterBase
	{
		// This class was created to read and write XML files generated by Excel
		// Feel free to create your own adapter based on a different schema
		
		private var excelBaseXML:String = '<?xml version="1.0"?><Workbook>{data}</Workbook></xml>'// '<?xml version="1.0"?>\n<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"\n xmlns:o="urn:schemas-microsoft-com:office:office"\n xmlns:x="urn:schemas-microsoft-com:office:excel"\n xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"\n xmlns:html="http://www.w3.org/TR/REC-html40">\n<OfficeDocumentSettings xmlns="urn:schemas-microsoft-com:office:office">\n</OfficeDocumentSettings>\n <ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">\n</ExcelWorkbook>\n<Worksheet ss:Name="{name}">\n<Table ss:ExpandedColumnCount="3" ss:ExpandedRowCount="6" x:FullColumns="1"\n x:FullRows="1">\n{data}\n</Table>\n<WorksheetOptions xmlns="urn:schemas-microsoft-com:office:excel">\n<Selected/>\n</WorksheetOptions>\n </Worksheet>\n</Workbook>'
		private var excelBaseRow:String = '<Row>\n{data}</Row>\n'
		private var excelBaseCell:String = '<Cell><Data ss:Type="String">{data}</Data></Cell>\n'
		
		public function XMLAdapter( model:ModelBase, cache:Cache, data:Data )
		{
			super( model, cache, data );
		}
		
		override public function export( id:int=0, params:Object=null ) : String
		{
			var result:String = "";
			var string:String = ""
			var row:String = "";
			var column:String;
			var clazz:* = data.getClass( model.className );
			var columns:Array = [];
			var cells:String = "";
			var value:*;
			if( params && params.exclude is Array ){
				for each( column in data.columns( model.className ) ){
					if( params.exclude.indexOf( column ) == -1 && data.columnsLocked( model.className ) != true ){
						columns.push( column );
					}
				}
			}else{
				columns = data.columns( model.className );
			}
			
			for each( column in columns ) {
				cells += excelBaseCell.split("{data}").join( column );
			}
			string += excelBaseRow.split("{data}").join(cells);
			
			if( id == 0 ) {
				for each( var item:* in clazz["all"]() ){
					cells = ""
					for each( column in columns ){
						value = item[column];
						if( value is Array ) {
							value = String(value.length) + " " + StringUtils.pluralize(value[0].className); 
						}else if( value == null ){
							value = ""; 
						}
						cells += excelBaseCell.split("{data}").join( value );
					}
					string += excelBaseRow.split("{data}").join(cells);
				}
			}else{
				cells = ""
				for each( column in columns ){
					value = clazz["findById"]( id )[ column ];
					if( value is Array ) {
						value = String(value.length) + " " + StringUtils.pluralize(value[0].className); 
					}else if( value == null ){
						value = ""; 
					}
					cells += excelBaseCell.split("{data}").join( value );
				}
				string += excelBaseRow.split("{data}").join(cells);
			}
			result = excelBaseXML.split("{data}").join(string).split("{name}").join(model.className);
			return result;
		}
		
		public function load( path:String ):void
		{
			assets.add( path ).addEventListener( Event.COMPLETE, onLoad );
			assets.load();
		}
		
		public function parse( source:String ):void
		{
			var xml:XML = new XML( source );
			var className:String = ClassUtils.className( model );
			var clazz:Class = data.getClass( className );
			var headerSet:Boolean = false;
			var ns:Namespace = xml.namespace();
			var columns:Array = [];
			for each( var r:XML in xml..ns::Row ) {
				var cell:XML;
				if( !headerSet ){
					for each( cell in r.ns::Cell.ns::Data ) {
						var value:String = cell.text().toString();
						if( data.columnsLocked( className ) != true ) {
							data.columns( className ).push( value );
						}
						columns.push( value );
					}
					headerSet = true;
				}else{
					var instance:* = new clazz();
					var index:int = data.push( className, instance );
					var count:int = 0;
					for each( cell in r.ns::Cell.ns::Data ) {
						var column:String = columns[count];
						for each( var at:XML in cell.@*){
							if(at.toString() == "String"){
								instance[column] = cell.text().toString();
							}else if(at.toString() == "Number"){
								instance[column] = parseFloat(cell.text().toString());
							}
						}
						if( data.isAssociatedProperty( className, column ) ){
							var associatedObject:* = data.getAssociationForProperty(className, column)["class"].findById( cell );
							if( associatedObject != null ){
								var name:String = StringUtils.pluralize( className ).toLowerCase();
								if( !associatedObject.hasOwnProperty( name ) ) {
									associatedObject[ name ] = [];
								}
								associatedObject[ name ].push( instance );
							}
						}
						count++
					}
					instance.index = index;
				}
			}
		}
		
		private function onLoad( event:Event ):void
		{	
			parse( event.target.data );
			data.dispatchEvent(new Event( "dataLoaded" ) );
		}
	}
}